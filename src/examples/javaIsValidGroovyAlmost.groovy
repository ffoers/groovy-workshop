import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString
import groovy.transform.TupleConstructor

// Groovy is a programming language for the JVM.
// In most cases, Java Code is valid Groovy Coce. However, there are a few semantic differences as shown below.
// Groovy is written without semicolons.
// Classes and Methods are public by default. Private stuff is still accessible.
// Besides writing Groovy classes instead of Java classes, there are other ways to execute groovy.
// One of them are used in this script. If you have groovy installed, you can execute any .groovy file just like an interpreted
// script in Python or Ruby. What really happens is that groovy creates a class with the same name as the file, creates a main-method and executes it.
// Self-contained scripts such as these can use grapes for dependency management.
// You can have multiple classes in one .groovy file, none of which has to have the same name as the file itself.

// Most Java Code is working Groovy Code.

public class SomeClass {
    private String aProperty;

    String getaProperty() {
        return aProperty
    }

    void setaProperty(String aProperty) {
        this.aProperty = aProperty
    }

    public SomeClass(String aProperty) {
        this.aProperty = aProperty; ;
    }
}

assert new SomeClass('Hello World!');

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
// Beware! There are some differences.
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
// - As you can see, in Groovy, assertions are always turned on
////////////////////////////////////////////////////////////////////////////////////////////////
assert true

try {
    assert false
} catch (Throwable a) {
    // Java would throw another exception!
    assert a.getClass() == org.codehaus.groovy.runtime.powerassert.PowerAssertionError
}

////////////////////////////////////////////////////////////////////////////////////////////////
// - The equals operator '==' actually calls the equals method
////////////////////////////////////////////////////////////////////////////////////////////////

class MyClass {
    String message

    public MyClass(String message) {
        this.message = message
    }

    //equals method generated by the IDE
    boolean equals(o) {
        if (this.is(o)) return true
        if (getClass() != o.class) return false

        MyClass myClass = (MyClass) o

        if (message != myClass.message) return false

        return true
    }
}

MyClass ma = new MyClass('Hello World!')
MyClass mb = new MyClass('Hello World!')

assert ma == mb
assert !ma.is(mb)

////////////////////////////////////////////////////////////////////////////////////////////////
// Classes are first-class citizens
////////////////////////////////////////////////////////////////////////////////////////////////
assert 'Hi there!'.class == String

////////////////////////////////////////////////////////////////////////////////////////////////
// return keyword is optional
////////////////////////////////////////////////////////////////////////////////////////////////
def identity(thing) {
    thing
}

assert identity('Hello World!') == 'Hello World!'

////////////////////////////////////////////////////////////////////////////////////////////////
// Strings
////////////////////////////////////////////////////////////////////////////////////////////////

'this is a "String"'

"this is a 'GString'"
String greeting = 'Hello'
String subject = 'World!'

assert greeting + ' ' + subject == "$greeting ${subject}"
assert 'Guinea Pig'[1] == 'u'

////////////////////////////////////////////////////////////////////////////////////////////////
// Groovy truth
// - all non-null values of classes without a 'boolean asBoolean()' method
// - non-empty collections
// - matching regex matchers
// - non-empty strings
// - non-null numbers
////////////////////////////////////////////////////////////////////////////////////////////////
assert new MyClass('Hello')
assert !null
assert ![]
assert ('a' =~ /a/)
assert !''
assert 'a'
assert 1
assert !0

/////////////////
class Helper {
    int amount = 0

    boolean asBoolean() {
        amount != 0
    }
}

Helper helper = new Helper()

assert !helper
helper.amount = 22
assert helper

////////////////////////////////////////////////////////////////////////////////////////////////
// collection literals
// there is a huge number of neat methods for collections, just look at the intelliSense of your IDE
////////////////////////////////////////////////////////////////////////////////////////////////
List list = [1, 2]
assert list[0] == 1

Map<String, String> map = ['a': 'b', 'c': 'd']
Map<String, String> map1 = [a: 'b', c: 'd']
assert map == map1
assert map['a'] == map1.a

////////////////////////////////////////////////////////////////////////////////////////////////
// Property Access
////////////////////////////////////////////////////////////////////////////////////////////////

class Holder {
    String holdee
}

Holder holder = new Holder()
holder.holdee = 'Hello World!'
assert holder.holdee == 'Hello World!'

holder.setHoldee('Hello World!')
assert holder.getHoldee() == 'Hello World!'

class Holder2 {
    int i

    void setI(int to) {
        i = to + 1
    }
}

Holder2 holder2 = new Holder2()
holder2.i = 2
assert holder2.i == 3

////////////////////////////////////////////////////////////////////////////////////////////////
// Closures
////////////////////////////////////////////////////////////////////////////////////////////////
assert { 2 + 2 }() == 4

assert { it + 1 }(2) == 3

assert { String aString -> aString.length() }('Hello World!') == 12

////////////////////////////////////////////////////////////
def executor1(Closure closure) {
    closure()
}

assert executor1({ 3 }) == 3
////////////////////////////////////////////////////////////
def executor2(Closure closure) {
    closure(1)
}

assert executor2 { it + it } == 2
////////////////////////////////////////////////////////////
def executor3(int i, Closure closure) {
    closure(i)
}

assert executor3(1) { it++ }
////////////////////////////////////////////////////////////

Closure incrementor(int by) {
    return { it + by }
}

Closure byOne = incrementor(1)
assert byOne(5) == 6
assert incrementor(1)(3)
//TODO: MORE

////////////////////////////////////////////////////////////

Closure helloWorldContains = 'Hello World!'.&contains
assert helloWorldContains('H')
assert !helloWorldContains('y')
////////////////////////////////////////////////////////////////////////////////////////////////
// interesting operators
////////////////////////////////////////////////////////////////////////////////////////////////

//nullsafe operator
class StupidClass {
    String stupid() {
        null
    }
}

assert new StupidClass().stupid()?.length() == null

// elvis operator
assert ('' ?: 'something') == 'something'
assert ('other' ?: 'something') == 'other'

// spread operator
assert [0, 1]*.toString() == ['0', '1']

////////////////////////////////////////////////////////////////////////////////////////////////
// Collection Magic
////////////////////////////////////////////////////////////////////////////////////////////////


assert [2, 3].reverse() == [3, 2]
assert [3, 6, 1].sort() == [1, 3, 6]
assert [1, 2].any { it == 2 }
assert [1, 2].any { it == 3 } == false
assert [2, 8, 4].collect { it + 3 } == [5, 11, 7]
assert [3, 1, 8].tail() == [1, 8]
assert [2, 3].permutations() == [[3, 2], [2, 3]] as Set
assert [2, 3, 4, 5, 6].find { it % 2 == 0 } == 2
assert [2, 3, 4, 5, 6].findAll { it % 2 == 0 } == [2, 4, 6]

assert [2, 3, 4].every { it > 2 } == false
assert [2, 3, 4].inject(5) { acc, val -> acc } == 5

////////////////////////////////////////////////////////////////////////////////////////////////
// AST Magic
////////////////////////////////////////////////////////////////////////////////////////////////
// Other AST Transformation you should have a look at:
// @Slf4J
// @Singleton
// @TailRecursive
// @Builder
// @Sortable
// @IndexedProperty
// @TypeChecked

class StringHolder {
    @Lazy
    String s = {
        println 'init string'
        'init string'
    }()

    def identityFunction(s) {
        s
    }
}

StringHolder stringHolder = new StringHolder()
println 'stringHolder created'
println "init String: ${stringHolder.s}"


class StringHolder2 {
    @Delegate
    StringHolder stringHolder1 = new StringHolder()
}

StringHolder2 stringHolder2 = new StringHolder2()
assert stringHolder2.identityFunction('init string') == 'init string'

@ToString
@TupleConstructor
@EqualsAndHashCode
//@Canonical
//@Immutable
class ToStringClass {
    String part
}

ToStringClass toStringClass = new ToStringClass(part: 'Ork')
assert toStringClass.toString() == 'ToStringClass(Ork)'
